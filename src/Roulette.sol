// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.7;

import "../lib/chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol";
import "../lib/chainlink/contracts/src/v0.8/ConfirmedOwner.sol";
import "../lib/forge-std/src/console.sol";

contract Roulette is VRFV2WrapperConsumerBase, ConfirmedOwner {
    struct RequestStatus {
        uint256 paid; // amount paid in link
        bool fulfilled; // whether the request has been successfully fulfilled
        uint256[] randomWords;
        address player;
    }

    mapping(uint256 => RequestStatus) private _requestStatus; /* gameId --> requestStatus */

    mapping(uint256 => uint256) public userBalance; /* gameId -> ether payed for game */
    mapping(address => mapping(uint256 => uint8)) public guessValue; // userAddress -> gameId -> guess;

    // past requests Id.
    uint256[] public gameIds;
    uint256 public lastgameId;

    uint32 callbackGasLimit = 100000;

    // The default is 3, but you can set this higher.
    uint16 requestConfirmations = 3;

    // For this example, retrieve 2 random values in one request.
    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.
    uint32 numWords = 1;

    // Address LINK - hardcoded for Goerli
    address linkAddress = 0x326C977E6efc84E512bB9C30f76E30c160eD06FB;

    // address WRAPPER - hardcoded for Goerli
    address wrapperAddress = 0x708701a1DfF4f478de54383E49a627eD4852C816;

    uint256 initialOwnerBalance;

    /**
     * @notice Emitted after new game is successfully initaited
     * @param gameId The Id of the newly created game
     */
    event GameRequest(uint256 gameId);

    /**
     * @notice Emitted After fulfillRandomWords function called successfullly
     * @param gameId The Id of the newly created game
     * @param result The random number generated by chainlink
     */
    event GameResult(uint256 gameId, uint256 result);

    /**
     * @notice Emitted After claimPrize function called and notify weather the player won or lost for particular gameId
     * @param won True if player wins or false if lost
     * @param gameId The Id of the newly created game
     */
    event Result(bool indexed won, uint256 gameId);

    constructor() ConfirmedOwner(msg.sender) VRFV2WrapperConsumerBase(linkAddress, wrapperAddress) {}

    /**
     * @notice Create a new game.
     * @dev Calls `requestRandomness()` to get a random number from Chainlink's VRF.
     *      Requires the contract to hold a minimum amount of LINK.
     * 	 User pays the fee to request randomness
     * @param guess Number guessed by the user. 0-36 are bets on the number.
     *              37 is a bet on RED (odd numbers). 38 is a bet on BLACK(even numbers).
     */
    function newGame(uint8 guess) external payable returns (uint256 gameId) {
        uint256 gasFee = VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit);
        console.log(gasFee);
        LINK.transferFrom(msg.sender, address(this), gasFee);
        uint256 amountToStake = maximumAmountToStake();
        require(guess <= 38, "Invalid guess");
        require(msg.value > 0 && msg.value <= amountToStake, "ETH > 0 || ETH <= Max_amount_to_stake");
        gameId = requestRandomWords(msg.sender);
        guessValue[msg.sender][gameId] = guess;
        userBalance[gameId] = msg.value;

        emit GameRequest(gameId);
    }

    /**
     * @notice Is used to claim a prize if the caller is initaited the game and
     * 		   wins weather for number or color. If not won the game it emits the Result
     *         event with won == false
     * @param gameId The Id of the game
     */
    function claimPrize(uint256 gameId) external {
        require(_requestStatus[gameId].paid > 0, "gameId not found");
        require(_requestStatus[gameId].player == msg.sender, "Youre not initaited this game");
        require(_requestStatus[gameId].fulfilled, "Random Number not generated");

        uint8 guess = guessValue[msg.sender][gameId];
        uint8 result = uint8(_requestStatus[gameId].randomWords[0] % 38);
        console.log("result", result);
        uint256 stakedAmount = userBalance[gameId];
        bool won;
        if ((guess == 37) && result % 2 != 0) {
            won = true;
            (bool success,) = msg.sender.call{value: stakedAmount * 2}("");
            require(success, "Transfer not finished");
        } else if ((guess == 38) && result % 2 == 0) {
            won = true;
            (bool success,) = msg.sender.call{value: stakedAmount * 2}("");
            require(success, "Transfer not finished");
        } else if (result <= 36 && guess == result) {
            won = true;
            (bool success,) = msg.sender.call{value: stakedAmount * 36}("");
            require(success, "Transfer not finished");
        } else {
            won = false;
        }
        emit Result(won, gameId);
    }

    /**
     * @notice Used to liquidate the contract
     */
    function addLiquidity() external payable onlyOwner {
        initialOwnerBalance += msg.value;
    }

    /**
     * @notice Returns owner initial balance staked to initiate the game when there is enough liquidity
     *         Assume 10 ether is enough
     */
    function returnOwnerIntialBalance(uint256 _amount) external onlyOwner {
        require(address(this).balance >= 10 ether, "Not enough liquidity");
        initialOwnerBalance -= _amount;
        (bool success,) = msg.sender.call{value: _amount}("");
        require(success, "transfer failed");
    }

    /**
     * @notice Used to get the request status of a particular gameId
     * @param _gameId The Id of the game
     */
    function getRequestStatus(uint256 _gameId)
        external
        view
        returns (uint256 paid, bool fulfilled, uint256[] memory randomWords)
    {
        require(_requestStatus[_gameId].paid > 0, "request not found");
        RequestStatus memory request = _requestStatus[_gameId];
        return (request.paid, request.fulfilled, request.randomWords);
    }

    /**
     * @notice Used to get the price needed to request randomness
     */
    function getRequestPrice() external view returns (uint256) {
        return VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit);
    }

    /**
     * @notice Used to get the balance of the contract
     * @return Returns the number of ether available
     */
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice Used to get maximum number of ETH to stake;
     * @return Returns the maximum number to stake
     */
    function maximumAmountToStake() public view returns (uint256) {
        return address(this).balance / 36;
    }

    /**
     * @notice Function called by Chainlink's VRF wrapper to inform the randomly generated words.
     * @dev Should be implemented as `internal`.
     * @param _gameId ID of the request.
     * @param _randomWords Array of randomly generated words.
     */
    function fulfillRandomWords(uint256 _gameId, uint256[] memory _randomWords) internal override {
        require(_requestStatus[_gameId].paid > 0, "request not found");
        _requestStatus[_gameId].fulfilled = true;
        _requestStatus[_gameId].randomWords = _randomWords;
        emit GameResult(_gameId, _randomWords[0]);
    }

    /**
     * @notice Used to request random number from chainlink
     */
    function requestRandomWords(address _player) internal returns (uint256 gameId) {
        gameId = requestRandomness(callbackGasLimit, requestConfirmations, numWords);
        _requestStatus[gameId] = RequestStatus({
            paid: VRF_V2_WRAPPER.calculateRequestPrice(callbackGasLimit),
            randomWords: new uint256[](0),
            fulfilled: false,
            player: _player
        });
        gameIds.push(gameId);
        lastgameId = gameId;
    }
}
